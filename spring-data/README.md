# Spring Data
**_Thumbs of rules:_**
- ðŸ”’ **See** [POLA](https://en.wikipedia.org/wiki/Principle_of_least_astonishment): 

    Which meant for each entity 
by default it can get its data only (all fetch type should be **LAZY**), in case we want to fetch associated entities, 
let's do that in your **repository** or **service**.
- ðŸ‘€ **Smell the issue:** 

  Attention to SQL generated by the framework. 
  To smell them, your local development must enable the log to see what's going on.

      **_application.properties_**
      ```
      spring.jpa.show-sql=true
      spring.jpa.properties.hibernate.format_sql=true
      spring.jpa.open-in-view=false
    
      logging.level.org.springframework.orm.jpa=DEBUG
      logging.level.org.springframework.transaction=DEBUG
      ```
## Entity State

---

## Entity Relationship
### 1-1: One To One
![img_1.png](docs/one-one.png)
#### Fetch Type
- Fetch Lazy for both side.
- Apply **Share Key** for one-to-one relationship. See `@PrimaryKeyJoinColumn`, `@MapsId`.
- When using **Share Key**, remember to set `optional = false` otherwise, 
fetch lazy will not work then we will get N+1 problem.

After above setting up: when you try to get parent, child will not come together. If you want to get all of them let consider
using `@EntityGrapths` with **JPA Query Method** to fetch the child with parent.

**_Code_**
```java
@Entity
@Table(name = "app_user")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL, optional = false)
    @PrimaryKeyJoinColumn
    private Address address;
}

@Entity
@Table(name = "app_user_address")
public class Address {

    @Id
    @Column(name = "user_id")
    private Long id;

    private String value;

    @OneToOne(fetch = FetchType.LAZY)
    @MapsId
    @JoinColumn(name = "user_id")
    @JsonBackReference
    private User user;
}
```
- [The best way to use the JPA OneToOne optional attribute](https://vladmihalcea.com/best-way-onetoone-optional/)
#### Cascade Type

### 1-N: One To Many:
![img_4.png](docs/one-n.png)
**_Code_**
```java
@Entity
@Table(name = "app_user")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @OneToOne(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL, optional = false)
    @PrimaryKeyJoinColumn
    private Address address;

    @OneToMany(mappedBy = "user")
    @JsonManagedReference
    private Set<Post> posts;
}

@Entity
@Table(name = "app_post")
public class Post {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String content;

    @ManyToOne(fetch = FetchType.LAZY)
    @JsonBackReference
    private User user;

}
```




---

## Persistence Type

---
## Fetch Type
### LAZY
- Why lazy fetch must be in transactional context
### EAGER
- Why eager sometimes face **N+1** problem.
### Best Practices
- Consider Lazy for all, using `@EntityGraphs` or 
`JPA Query Method` to get associated entities.

---
## Best Practices
### Understand entity state to optimize JPA functionalities.